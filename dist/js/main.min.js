"use strict";

/*
 * classList.js: Cross-browser full element.classList implementation.
 * 1.1.20150312
 *
 * By Eli Grey, http://eligrey.com
 * License: Dedicated to the public domain.
 *   See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
 */

/*global self, document, DOMException */

/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */

if ("document" in self) {

	// Full polyfill for browsers with no classList support
	// Including IE < Edge missing SVGElement.classList
	if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {

		(function (view) {

			"use strict";

			if (!('Element' in view)) return;

			var classListProp = "classList",
			    protoProp = "prototype",
			    elemCtrProto = view.Element[protoProp],
			    objCtr = Object,
			    strTrim = String[protoProp].trim || function () {
				return this.replace(/^\s+|\s+$/g, "");
			},
			    arrIndexOf = Array[protoProp].indexOf || function (item) {
				var i = 0,
				    len = this.length;
				for (; i < len; i++) {
					if (i in this && this[i] === item) {
						return i;
					}
				}
				return -1;
			}
			// Vendors: please allow content code to instantiate DOMExceptions
			,
			    DOMEx = function DOMEx(type, message) {
				this.name = type;
				this.code = DOMException[type];
				this.message = message;
			},
			    checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
				if (token === "") {
					throw new DOMEx("SYNTAX_ERR", "An invalid or illegal string was specified");
				}
				if (/\s/.test(token)) {
					throw new DOMEx("INVALID_CHARACTER_ERR", "String contains an invalid character");
				}
				return arrIndexOf.call(classList, token);
			},
			    ClassList = function ClassList(elem) {
				var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
				    classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
				    i = 0,
				    len = classes.length;
				for (; i < len; i++) {
					this.push(classes[i]);
				}
				this._updateClassName = function () {
					elem.setAttribute("class", this.toString());
				};
			},
			    classListProto = ClassList[protoProp] = [],
			    classListGetter = function classListGetter() {
				return new ClassList(this);
			};
			// Most DOMException implementations don't allow calling DOMException's toString()
			// on non-DOMExceptions. Error's toString() is sufficient here.
			DOMEx[protoProp] = Error[protoProp];
			classListProto.item = function (i) {
				return this[i] || null;
			};
			classListProto.contains = function (token) {
				token += "";
				return checkTokenAndGetIndex(this, token) !== -1;
			};
			classListProto.add = function () {
				var tokens = arguments,
				    i = 0,
				    l = tokens.length,
				    token,
				    updated = false;
				do {
					token = tokens[i] + "";
					if (checkTokenAndGetIndex(this, token) === -1) {
						this.push(token);
						updated = true;
					}
				} while (++i < l);

				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.remove = function () {
				var tokens = arguments,
				    i = 0,
				    l = tokens.length,
				    token,
				    updated = false,
				    index;
				do {
					token = tokens[i] + "";
					index = checkTokenAndGetIndex(this, token);
					while (index !== -1) {
						this.splice(index, 1);
						updated = true;
						index = checkTokenAndGetIndex(this, token);
					}
				} while (++i < l);

				if (updated) {
					this._updateClassName();
				}
			};
			classListProto.toggle = function (token, force) {
				token += "";

				var result = this.contains(token),
				    method = result ? force !== true && "remove" : force !== false && "add";

				if (method) {
					this[method](token);
				}

				if (force === true || force === false) {
					return force;
				} else {
					return !result;
				}
			};
			classListProto.toString = function () {
				return this.join(" ");
			};

			if (objCtr.defineProperty) {
				var classListPropDesc = {
					get: classListGetter,
					enumerable: true,
					configurable: true
				};
				try {
					objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
				} catch (ex) {
					// IE 8 doesn't support enumerable:true
					if (ex.number === -0x7FF5EC54) {
						classListPropDesc.enumerable = false;
						objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
					}
				}
			} else if (objCtr[protoProp].__defineGetter__) {
				elemCtrProto.__defineGetter__(classListProp, classListGetter);
			}
		})(self);
	} else {
		// There is full or partial native classList support, so just check if we need
		// to normalize the add/remove and toggle APIs.

		(function () {
			"use strict";

			var testElement = document.createElement("_");

			testElement.classList.add("c1", "c2");

			// Polyfill for IE 10/11 and Firefox <26, where classList.add and
			// classList.remove exist but support only one argument at a time.
			if (!testElement.classList.contains("c2")) {
				var createMethod = function createMethod(method) {
					var original = DOMTokenList.prototype[method];

					DOMTokenList.prototype[method] = function (token) {
						var i,
						    len = arguments.length;

						for (i = 0; i < len; i++) {
							token = arguments[i];
							original.call(this, token);
						}
					};
				};
				createMethod('add');
				createMethod('remove');
			}

			testElement.classList.toggle("c3", false);

			// Polyfill for IE 10 and Firefox <24, where classList.toggle does not
			// support the second argument.
			if (testElement.classList.contains("c3")) {
				var _toggle = DOMTokenList.prototype.toggle;

				DOMTokenList.prototype.toggle = function (token, force) {
					if (1 in arguments && !this.contains(token) === !force) {
						return force;
					} else {
						return _toggle.call(this, token);
					}
				};
			}

			testElement = null;
		})();
	}
}

/**
 * Module containing helper functions to be imported and used in main module.
 * @return {Object} publicApi - Api containing references to the module functions.
 */
var momentumHelperModule = function momentumHelperModule() {
	var data = {}; // Variable holding previously fetched data. Used to avoid doing a GET request more than once
	var apiUrl = ''; // The root URL of the API
	var whichAnimationEvent = getCurrentAnimationEvent(); // Which animation end event the current browser uses

	/**
  * Do a GET request.
  * @param {String} request - The API request.
  * @param {Function} callback - The function to call once the JSON data is fetched.
  */
	function doRequest(request, callback) {
		var url; // Where to send GET request
		var xhr; // XHR object

		url = apiUrl + "/" + request;
		xhr = new XMLHttpRequest();

		// Support for multiple browsers
		if ('withCredentials' in xhr) {

			// XHR for Chrome/Firefox/Opera/Safari.
			xhr.open('GET', url, true);
		} else if (typeof XDomainRequest != 'undefined') {

			// XDomainRequest for IE.
			xhr = new XDomainRequest();

			// Ensure every request is unique and does not get cached, by appending random to the request url
			url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
			xhr.open('GET', url);
		} else {

			// CORS not supported.
			xhr = null;
		}

		if (!xhr) {
			return;
		}

		// Response handlers
		xhr.onload = function () {
			callback(xhr.responseText);
		};

		xhr.onerror = function () {};

		// These blank handlers need to be set to fix ie9 http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/
		xhr.onprogress = function () {};
		xhr.ontimeout = function () {};

		// Send request wrapped in timeout to fix ie9
		setTimeout(function () {
			xhr.send();
		}, 0);
	}

	/**
  * Do a POST request.
  * @param {String} request - The API request.
  * @param {String} params - The parameters to send.
  * @param {Function} callback - The function to call once the JSON data is fetched.
  */
	function doPost(request, params, callback) {
		var url; // Where to send POST request
		var xhr; // XHR object

		url = apiUrl + "/" + request;
		xhr = new XMLHttpRequest();

		// Support for multiple browsers
		if ('withCredentials' in xhr) {

			// XHR for Chrome/Firefox/Opera/Safari.
			xhr.open('POST', url, true);
			xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
		} else if (typeof XDomainRequest != 'undefined') {

			// XDomainRequest for IE.
			xhr = new XDomainRequest();

			// Ensure every request is unique and does not get cached, by appending random to the request url
			url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
			xhr.open('POST', url);
		} else {

			// CORS not supported.
			xhr = null;
		}

		if (!xhr) {
			return;
		}

		// Response handlers
		xhr.onload = function () {
			callback(xhr.responseText);
		};

		xhr.onerror = function () {};

		// These blank handlers need to be set to fix ie9 http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/
		xhr.onprogress = function () {};
		xhr.ontimeout = function () {};

		// Send request wrapped in timeout to fix ie9
		setTimeout(function () {
			xhr.send(params);
		}, 0);
	}

	/**
  * Get data from API.
  * @param {String} request - The API request.
  * @param {Function} callback - The function to call once the JSON data is fetched.
  */
	function getApiData(request, callback) {
		var result; // Http request result

		// If data already stored, skip sending GET request and just execute the callback with it directly
		if (request in data) {
			callback(data[request]);
			return;
		}

		// Data does not already exist, launch GET request to API
		doRequest(request, function handleParsedJSON(result) {
			result = JSON.parse(result);

			// Store data in global data object to more easily fetch again later
			if (result.length > 0 && !(request in data)) {
				data[request] = result;
			}

			callback(result);
		});
	}

	/**
  * Post data to the API.
  * @param {String} request - The API request.
  * @param {String} params - The parameters to send.
  * @param {String|Boolean} dataKey - The data key the results should be appended to (if it exists).
  * @param {Function} callback - The function to call once the data is posted.
  */
	function postApiData(request, params) {
		var dataKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var callback = arguments[3];

		var result; // Result from the post
		callback = callback || function () {};

		doPost(request, params, function handleParsedJSON(result) {
			result = JSON.parse(result);

			// Append the result to data if needed
			if (dataKey && dataKey in data) {
				data[dataKey].push(result);
			}

			callback(result);
		});
	}

	/**
  * Animate an element.
  * @param {Object} element - The element to fade.
  * @param {Array} animationNames - Array containing the class(es) to add for the animation.
  * @param {Function} callback - Function to call once fade is done.
  */
	function animateElem(element, animationNames, callback) {
		callback = callback || function () {};

		setData(element, 'animating', true);
		animationNames.push('animated');

		for (var i = 0; i < animationNames.length; i++) {
			element.classList.add(animationNames[i]);
		}

		// If animation end event exists, wait for it to execute callback. Otherwise, execute it now
		if (whichAnimationEvent) {
			addAnimEventOnce(element, whichAnimationEvent, function afterAnimationEnd(e) {
				for (var j = 0; j < animationNames.length; j++) {
					element.classList.remove(animationNames[j]);
				}

				setData(element, 'animating', false);
				callback();
			});
		} else {
			for (var j = 0; j < animationNames.length; j++) {
				element.classList.remove(animationNames[j]);
			}

			setData(element, 'animating', false);
			callback();
		}

		/**
   * Add a one-time event for the duration of an animation.
   * @param {Object} element - The target element.
   * @param {String} type - The type of the event.
   * @param {Function} callback - The callback exeto attach to the event.
   */
		function addAnimEventOnce(element, type, callback) {
			addEvent(element, type, function fn(event) {
				removeEvent(element, type, fn);
				callback(event);
			});
		}
	}

	/**
  * 'addEventListener' polyfill.
  * @param {Object} element - The element to add the event listener to.
  * @param {Event} type - The event type.
  * @param {Function} callback - The event listener function callback.
  */
	function addEvent(element, type, callback) {
		if (element.addEventListener) {
			element.addEventListener(type, callback, false);
		} else if (element.attachEvent) {
			element.attachEvent("on" + type, function () {
				return callback.apply(element, arguments);
			});
		} else {
			element['on' + type] = callback;
		}
	}

	/**
  * 'removeEventListener' polyfill.
  * @param {Object} element - The element to add the event listener to.
  * @param {Event} type - The event type.
  * @param {Function} callback - The event listener function callback.
  */
	function removeEvent(element, type, callback) {
		if (element.removeEventListener) {
			element.removeEventListener(type, callback, false);
		} else if (element.detachEvent) {
			element.detachEvent("on" + type, callback);
		} else {
			element['on' + type] = null;
		}
	}

	/**
  * Returns the boolean value of an element's data attribute(s).
  * @param {Object} element - The element.
  * @param {String|Array} data - String of data attribute, or array of all data attributes to check.
  * @param {Boolean} dataTruth - Whether the data attribute evaluates to true.
  */
	function isElem(element, data) {
		if (data.constructor === Array) {
			for (var i = 0; i < data.length; i++) {
				if (getData(element, [data[i]]) === 'true') {
					return true;
				}
			}

			return false;
		}
		return getData(element, [data]) === 'true';
	}

	/**
  * Set the module's apiUrl variable.
  * @param {String} url - The base api url.
  */
	function setApiUrl(url) {
		apiUrl = apiUrl ? apiUrl : url;
	}

	/**
  * Get all elements that have an attribute.
  * @param {String} attribute - The attribute to filter elements by.
  * @return {Array} elements - All elements with that attribute.
  */
	function getElemsWithAttr(attribute) {
		var matchingElements; // Elements that are matching
		var allElements; // Every element

		matchingElements = [];
		allElements = document.getElementsByTagName('*');

		for (var i = 0, n = allElements.length; i < n; i++) {
			if (allElements[i].getAttribute(attribute) !== null) {
				matchingElements.push(allElements[i]); // Element exists with attribute. Add to array.
			}
		}

		return matchingElements;
	}

	/**
  * Get next non-text element.
  * @param {Object} element - The element from which to start.
  * @return {Object} next - The element next of the starting one.
  */
	function getElemAfter(element) {
		var nextSibling; // The next element

		nextSibling = element.nextSibling;

		// Skip text nodes
		while (nextSibling != null && nextSibling.nodeType == 3) {
			nextSibling = nextSibling.nextSibling;
		}

		return nextSibling;
	}

	/**
  * Get previous non-text element.
  * @param {Object} element - The element from which to start.
  * @return {Object} next - The element next of the starting one.
  */
	function getElemBefore(element) {
		var previousSibling; // The previous element

		previousSibling = element.previousSibling;

		// Skip text nodes
		while (previousSibling != null && previousSibling.nodeType == 3) {
			previousSibling = previousSibling.previousSibling;
		}

		return previousSibling;
	}

	/**
  * Empty a DOM element of all its children.
  * @param {Object} element - The element to empty.
  */
	function emptyElem(element) {
		while (element.firstChild) {
			element.removeChild(element.firstChild);
		}
	}

	/**
  * Create an anchor tag element and return it.
  * @param {String} text - Text to place inside the anchor.
  * @param {String} href - Text to place inside href attribute.
  * @return {Object} elem - The anchor tag element.
 */
	function createAnchor(text, href) {
		var anchor; // Anchor element

		anchor = document.createElement('a');
		anchor.href = href || '#';

		if (text) {
			anchor.appendChild(document.createTextNode(text));
		}

		return anchor;
	}

	/**
  * Disable a form and all its inputs/buttons.
  * @param {Object} form - The form element.
  */
	function disableForm(form) {
		var children; // The form children

		children = form.children;

		for (var i = 0; i < children.length; i++) {
			children[i].setAttribute('disabled', 'true');
		}
	}

	/**
  * Enable a form and all its inputs/buttons.
  * @param {Object} form - The form element.
  */
	function enableForm(form) {
		var children; // The form children

		children = form.children;

		for (var i = 0; i < children.length; i++) {
			children[i].setAttribute('disabled', 'true');
			children[i].removeAttribute('disabled');
		}
	}

	/**
  * Clear a form of all its previously entered data.
  * @param {Object} form - The form element.
  */
	function clearForm(form) {
		var children; // The form children

		children = form.children;

		for (var i = 0; i < children.length; i++) {
			if (children[i].getAttribute('type') !== 'submit') {
				children[i].value = '';
			}
		}
	}

	/**
  * Set an element's data attribute. Polyfill for IE8.
  * @param {Object} elem - The element.
  * @param {String} data - The data attribute to set a value to.
  * @param {String} value - The value.
  */
	function setData(elem, data, value) {
		elem.setAttribute("data-" + data, value);
	}

	/**
  * Get an element's data attribute. Polyfill for IE8.
  * @param {Object} elem - The element.
  * @param {String} data - The data attribute to get the value from.
  * @return {String} value - The data attribute's value.
  */
	function getData(elem, data) {
		return elem.getAttribute("data-" + data);
	}

	/**
  * Get the current browser's correct animation end event name.
  */
	function getCurrentAnimationEvent() {
		var el; // Dummy element for test
		var a; // The current animation
		var animations; // All the different animations

		animations = {
			'transition': 'transitionend',
			'OTransition': 'oTransitionEnd',
			'MozTransition': 'transitionend',
			'WebkitTransition': 'webkitTransitionEnd'
		};

		animations = {
			'animation': 'animationend',
			'OAnimation': 'oAnimationEnd',
			'MozAnimation': 'animationend',
			'WebkitAnimation': 'webkitAnimationEnd'
		};

		el = document.createElement('fakeelement');

		for (a in animations) {
			if (el.style[a] !== undefined) {
				return animations[a];
			}
		}

		return false;
	}

	/**
 * Get the different requests to use to render content pages.
 * @return {Object} reqs - The requests.
 */
	function getRequests() {
		return {
			'userPosts': function userPosts(userId) {
				return {
					'query': "posts?userId=" + userId,
					'titleQuery': "users/" + userId,
					'type': 'posts'
				};
			},
			'userAlbums': function userAlbums(userId) {
				return {
					'query': "albums?userId=" + userId,
					'titleQuery': "users/" + userId,
					'type': 'userAlbums',
					'userId': userId
				};
			},
			'album': function album(albumId) {
				return {
					'query': "albums/" + albumId,
					'type': 'album'
				};
			},
			'photo': function photo(photoId) {
				return {
					'query': "photos/" + photoId,
					'type': 'photo'
				};
			},
			'allPosts': function allPosts(userId) {
				return {
					'query': "posts",
					'title': 'All Posts',
					'type': 'posts'
				};
			},
			'post': function post(postId) {
				return {
					'query': "posts/" + postId,
					'type': 'post'
				};
			},
			'user': function user(userId) {
				return {
					'query': "users/" + userId,
					'type': 'user'
				};
			}
		};
	}

	/**
  * Get references to app elements.
  * @return {Object} els - Object containing references to many static app elements.
  */
	function getAppElems() {
		return {
			contentBack: document.getElementById('content-back'),
			contentNext: document.getElementById('content-next'),
			dashboard: document.getElementById('dashboard'),
			dashboardContentPage: document.getElementById('content-dbp'),
			dashboardContentTitle: document.getElementById('dbp-content-title'),
			dashboardMenuPage: document.getElementById('main-dbp'),
			dbpContentContainer: document.getElementById('dbp-content-container'),
			dbpContentPageOne: document.getElementById('dbp-content-page-1'),
			loginForm: document.getElementById('login'),
			loginAlert: document.getElementById('login-alert'),
			loginBox: document.getElementById('login-box'),
			loginBtn: document.getElementById('login-btn'),
			loginField: document.getElementById('login-field'),
			loginPage: document.getElementById('login-page'),
			dashboardMenuItems: document.querySelectorAll('.dashboard-menu-item')
		};
	}

	return {
		'addEvent': addEvent,
		'animateElem': animateElem,
		'clearForm': clearForm,
		'createAnchor': createAnchor,
		'disableForm': disableForm,
		'emptyElem': emptyElem,
		'enableForm': enableForm,
		'getApiData': getApiData,
		'getAppElems': getAppElems,
		'getData': getData,
		'getElemAfter': getElemAfter,
		'getElemBefore': getElemBefore,
		'getElemsWithAttr': getElemsWithAttr,
		'getRequests': getRequests,
		'isElem': isElem,
		'postApiData': postApiData,
		'removeEvent': removeEvent,
		'setApiUrl': setApiUrl,
		'setData': setData
	};
}();
/**
 * Module containing functions pertaining to the app specifically, to be used in the other modules.
 * @param {Object} helper - Helper functions module.
 * @return {Object} publicApi - Api containing references to the module functions.
 */
var momentumFunctionsModule = function (helper) {

	var elems; // Object containing references to static, reused DOM elements
	var pageTitleBase; // The starting document title base
	var user; // The current user
	var requests; // The different requests to use to render content pages
	var dbp; // The templates module. Stands for "Dashboard pages"

	elems = helper.getAppElems();
	pageTitleBase = document.title;
	requests = helper.getRequests();

	/**
  * Get the currently active and displayed content page.
  * @return {Object||Boolean} element - The element if one is shown, or false.
  */
	function getActiveContentPage() {
		var dataCurrentContent; // Array of al elements with the "data-currentcontent" attribute

		dataCurrentContent = helper.getElemsWithAttr('data-currentcontent');

		for (var i = 0; i < dataCurrentContent.length; i++) {
			if (helper.isElem(dataCurrentContent[i], 'currentcontent')) {
				return dataCurrentContent[i];
			}
		}

		return false;
	}

	/**
  * Change the content page.
  * @param {String} direction - 'prev' or 'next'.
  * @param {Function} callback - Functions to call after page is changed.
  */
	function dbpChangePage(direction, callback) {
		var currentContentPage; // The currently active content page
		var newPage; // The new page being switched to

		currentContentPage = getActiveContentPage();
		callback = callback || function () {};

		switch (direction) {
			case 'previous':
				newPage = helper.getElemBefore(currentContentPage);

				newPage.classList.add('active');
				helper.setData(newPage, 'currentcontent', true);

				// Set next btn to active
				elems.contentNext.removeAttribute('disabled');
				afterChange();
				break;

			case 'next':
				newPage = helper.getElemAfter(currentContentPage);

				// Make sure next page is scrolled to top
				if (newPage) {
					newPage.scrollTop = 0;
				}

				newPage.classList.add('active');
				helper.setData(newPage, 'currentcontent', true);

				// If reached the end, make btn disabled
				if (helper.getElemAfter(newPage) == null) {
					elems.contentNext.setAttribute('disabled', true);
				}

				afterChange();
				break;

			default:
				break;
		}

		/**
   * Function executed after the page change.
   */
		function afterChange() {

			// Make current page inactive
			currentContentPage.classList.remove('active');
			helper.setData(currentContentPage, 'currentcontent', false);

			// Set the title
			elems.dashboardContentTitle.innerHTML = helper.getData(newPage, 'title');

			document.title = pageTitleBase + " - " + helper.getData(newPage, 'title');
			callback();
		}
	}

	/**
  * Handle click on content navigation back button.
  * @param {Event} event - The event.
  */
	function dbpPreviousClick(event) {
		var currentContentPage; // The currently active content page

		currentContentPage = getActiveContentPage();

		// If first page is current, slide dbp back in
		if (helper.getData(currentContentPage, 'pagenum') === '1') {
			transitionDashboardPage('slideIn');
			helper.setData(elems.dashboardContentPage, 'active', false);

			if (document.getElementById('active-dbp-btn')) {
				var activeMenuBtn = document.getElementById('active-dbp-btn');
				activeMenuBtn.classList.remove('active');
				activeMenuBtn.setAttribute('id', '');
				activeMenuBtn.blur();
			}
			return;
		}

		dbpChangePage('previous');
	}

	/**
  * Handle click on content navigation next button.
  * @param {Event} event - The event.
  */
	function dbpNextClick(event) {

		// If next page exists, change to it
		if (helper.getElemAfter(getActiveContentPage()) != null) {
			dbpChangePage('next');
		}
	}

	/**
  * Handle post comment form submit.
  * @param {Event} event - The event.
  */
	function submitPostComment(event) {
		var body; // The body value of the posted comment
		var commentsAmount; // The amount of comments already posted
		var commentsTitle; // Element containing title for comments section
		var currentPage; // Currently active page
		var form; // The form
		var name; // The 'name' or title value of the posted comment
		var params; // The parameters to send to the POST request
		var postId; // The ID of the post attached to the comment

		form = this;
		currentPage = getActiveContentPage();

		helper.disableForm(form);
		event.preventDefault ? event.preventDefault() : event.returnValue = false;

		if (!currentPage) {
			helper.enableForm(form);
			return;
		}

		commentsTitle = currentPage.querySelectorAll('[data-comments]')[0];

		// Cancel if can't get comments title
		if (!commentsTitle) {
			helper.enableForm(form);
			return;
		}

		// Get comment data
		name = form.elements['name'].value;
		body = form.elements['body'].value;

		// Cancel if either field is empty
		if (!name || !body) {
			helper.enableForm(form);
			return;
		}

		// Set page to "busy"
		setDbpBusyState(true);

		// Prepare POST request
		commentsAmount = parseInt(helper.getData(commentsTitle, 'comments'));

		postId = helper.getData(this, 'postid');

		params = "postId=" + postId + "&name=" + name + "&body=" + body + "&email=" + user.email;

		// Post the comment
		helper.postApiData('comments', params, "posts/" + postId + "/comments", function (result) {
			helper.enableForm(form);

			if (result) {
				helper.clearForm(form);

				addComment(currentPage, {
					'name': name,
					'body': body,
					'email': user.email,
					'newCommentsAmount': commentsAmount + 1
				});
			}
		});

		/**
   * Add the comment.
   * @param {Object} page - The page in which the comments reside.
   * @param {Object} commentData - All data on the comment.
   */
		function addComment(page, commentData) {
			var aroundAnchor; // Element wrapping around the userAnchor element
			var body; // The comment's body
			var comment; // The comment element
			var commentsElem; // Element containing all comments
			var commentsTitleText; // Text to be inserted in the comments section title
			var title; // The comment's title
			var userAnchor; // The anchor element used to email the user

			if (page) {

				// Comments
				commentsElem = page.querySelectorAll('.comments')[0];

				// Comment
				comment = document.createElement('div');
				comment.classList.add('list-group-item');

				// Comment title
				title = document.createElement('h4');
				title.classList.add('list-group-item-heading');
				title.appendChild(document.createTextNode(commentData.name));

				// User email anchor
				userAnchor = helper.createAnchor('Email this user', "mailto:" + commentData.email);
				userAnchor.classList.add('user-email');

				// Around user email anchor
				aroundAnchor = document.createElement('div');
				aroundAnchor.classList.add('around-anchor');
				aroundAnchor.appendChild(userAnchor);

				// Body
				body = document.createElement('p');
				body.classList.add('list-group-item-text');
				body.appendChild(document.createTextNode(commentData.body));

				// Append all
				comment.appendChild(title);
				comment.appendChild(aroundAnchor);
				comment.appendChild(body);
				commentsElem.insertBefore(comment, commentsElem.firstChild);

				// Update comments count
				commentsTitleText = commentData.newCommentsAmount + " comment";

				if (commentData.newCommentsAmount > 1) {
					commentsTitleText += 's';
				}

				helper.setData(commentsTitle, 'comments', commentData.newCommentsAmount);

				commentsTitle.removeChild(commentsTitle.firstChild);
				commentsTitle.appendChild(document.createTextNode(commentsTitleText));

				// Page no longer busy
				setDbpBusyState(false);
			}
		}
	}

	/**
  * Authenticate user on form submit.
  * @param {Event} event - The event.
  */
	function authenticate(event) {
		var username = elems.loginField.value;

		if (username) {

			helper.disableForm(elems.loginForm);

			helper.getApiData("users?username=" + username, function processResult(result) {

				if (result.length > 0) {
					user = result[0];
					login();
				} else {
					displayError("Username \"" + username + "\" does not exist.");
				}
			});
		}
		event.preventDefault ? event.preventDefault() : event.returnValue = false;

		/**
   * Log user in.
   */
		function login() {
			// Username exists, clear any previous error and show the "dashboard"
			elems.loginAlert.classList.remove('active');
			elems.loginBox.classList.remove('error');

			helper.setData(elems.dashboardContentPage, 'active', false);

			elems.dashboardContentPage.classList.remove('active');

			// Fade dashboard in
			elems.dashboard.classList.add('active');
			helper.animateElem(elems.dashboard, ['fadeInLeft']);

			// Fade login page out
			helper.animateElem(elems.loginPage, ['fadeOut'], function () {
				elems.loginPage.classList.remove('active');
				elems.dashboard.classList.add('active');
			});
		}

		/**
   * Display an error message on the login page after trying to authenticate the user.
   * @param {String} message - The message to display.
   */
		function displayError(message) {
			elems.loginAlert.innerHTML = "Username \"" + username + "\" does not exist.";
			elems.loginAlert.classList.add('active');
			elems.loginBox.classList.add('error');

			// Enable form and focus back on field
			helper.enableForm(elems.loginForm);
			elems.loginField.focus();
		}
	}

	/**
  * Log the user out and return to login page.
  * @param {Event} event - The event.
  */
	function logout(event) {
		user = {};

		// Prepare login page to be shown again
		helper.enableForm(elems.loginForm);
		elems.loginField.value = '';

		// Fade dashboard out
		helper.animateElem(elems.dashboard, ['fadeOutLeft'], function () {
			elems.dashboard.classList.remove('active');
		});

		// Fade login page in
		elems.loginPage.classList.add('active');

		// Reset the dashboard state
		resetDashboardState();

		helper.animateElem(elems.loginPage, ['fadeIn'], function () {
			elems.loginField.focus();
		});
		event.preventDefault ? event.preventDefault() : event.returnValue = false;
	}

	/**
  * Reset the entire dashboard state and remove all content from it.
  */
	function resetDashboardState() {

		// Reset active db button
		if (document.getElementById('active-dbp-btn')) {
			document.getElementById('active-dbp-btn').classList.remove('active');
			document.getElementById('active-dbp-btn').setAttribute('id', '');
		}

		// Reset head title
		document.title = pageTitleBase;

		// Reset dbps to their initial state
		resetDbpState();
	}

	/**
  * Reset the state of dbp to the original default one. Launch on tab change.
  */
	function resetDbpState() {

		// Remove all additional content pages
		while (helper.getElemAfter(elems.dbpContentPageOne) != null) {
			var nextElem = helper.getElemAfter(elems.dbpContentPageOne);
			nextElem.parentElement.removeChild(nextElem);
		}

		// Make first content page active
		helper.setData(elems.dbpContentPageOne, 'currentcontent', true);

		// Reset bottom buttons states
		elems.contentNext.disabled = true;

		// Empty the first content page
		elems.dashboardContentTitle.innerHTML = '';
		helper.emptyElem(elems.dbpContentPageOne);
	}

	/**
  * Function fired when a dashboard menu item is clicked.
  * @param {Event} event
  */
	function handleDashboardMenuClick(event) {
		var request; // Request attached to the clicked menu item

		event.preventDefault ? event.preventDefault() : event.returnValue = false;

		// If already busy being processed/animated or request doesn't exist, don't do anything
		if (helper.isElem(elems.dashboardContentPage, ['processing', 'animating']) || !(helper.getData(this, 'req') in requests)) {
			return;
		}

		// Reset dbps to their initial state
		resetDbpState();

		// If button clicked already active, slide page back in
		if (this.getAttribute('id') === 'active-dbp-btn') {
			transitionDashboardPage('slideIn');
			helper.setData(elems.dashboardContentPage, 'active', false);

			this.classList.remove('active');
			this.setAttribute('id', '');
			this.blur();
			return;
		}

		// Set any other active button as inactive
		if (document.getElementById('active-dbp-btn')) {
			var alreadyActive = document.getElementById('active-dbp-btn');
			alreadyActive.setAttribute('id', '');
			alreadyActive.classList.remove('active');
		}

		this.setAttribute('id', 'active-dbp-btn');
		this.classList.add('active');

		// Get request attached to this menu item
		var thisRequest = helper.getData(this, 'req');
		var requestFunc = requests[thisRequest];

		request = requestFunc(user.id);

		// Slide the second page in
		helper.setData(elems.dashboardContentPage, 'processing', true);

		if (helper.getData(elems.dashboardContentPage, 'active') === 'true') {
			elems.dashboardContentPage.classList.add('sliding');
			transitionDashboardPage('slideInOut');
		} else {
			transitionDashboardPage('slideOut');
		}

		// Set the content page state to "processing"
		setDbpBusyState(true);

		// Request the content and render page with it
		helper.getApiData(request.query, function (result) {
			dbp.render(result, request, elems.dbpContentPageOne);
		});
	}

	/**
  * Transition the dashboard page.
  * @param {String} type - The type of transition.
  * @param {Function} callback - Function to call after transition is over.
  */
	function transitionDashboardPage(type, callback) {
		helper.setData(elems.dashboardContentPage, 'animating', true);

		elems.dashboardContentPage.classList.add('active');
		callback = callback || function () {};

		switch (type) {
			case 'slideIn':
				helper.animateElem(elems.dashboardContentPage, ['slideOutLeft'], function () {
					helper.setData(elems.dashboardContentPage, 'animating', false);
					helper.setData(elems.dashboardContentPage, 'active', false);

					elems.dashboardContentPage.classList.remove('active');

					// Sliding back in, so reset head title
					document.title = pageTitleBase;
					callback();
				});
				break;

			case 'slideOut':
				helper.animateElem(elems.dashboardContentPage, ['fadeInLeft'], function () {
					helper.setData(elems.dashboardContentPage, 'animating', false);
					helper.setData(elems.dashboardContentPage, 'active', true);

					callback();
				});
				break;

			case 'slideInOut':
				helper.animateElem(elems.dashboardContentPage, ['slideOutLeft', 'fast'], function () {
					helper.animateElem(elems.dashboardContentPage, ['slideInLeft'], function () {
						helper.setData(elems.dashboardContentPage, 'animating', false);

						elems.dashboardContentPage.classList.remove('sliding');
						callback();
					});
				});
				break;

			default:
				break;
		}
	}

	/**
  * Manually grab and set a reference to the 'momentum-templates' module functions from outside.
  * @param {Object} module - The momentum-templates module's public API object.
  */
	function getDbpDependency(module) {
		dbp = module;
	}

	/**
  * Return the current user.
  * @return {Object} user - The currently logged-in user.
  */
	function getCurrentUser() {
		return user;
	}

	/**
  * Set the dashboard page processing state on/off.
  * @param {Boolean} set - Whether to set it on or off. 'true' is on.
  */
	function setDbpBusyState(state) {
		helper.setData(elems.dashboardContentPage, 'busy', state);

		if (state) {
			elems.dashboardContentPage.classList.add('busy');
		} else {
			elems.dashboardContentPage.classList.remove('busy');
		}
	}

	/**
  * Get whether the dashboard page is currently processing.
  * @return {Boolean} processing - Whether it's processing or not.
  */
	function dbpIsBusy() {
		return isElem(elems.dashboardContentPage, 'processing');
	}

	return {
		'authenticate': authenticate,
		'dbpChangePage': dbpChangePage,
		'dbpNextClick': dbpNextClick,
		'dbpPreviousClick': dbpPreviousClick,
		'getCurrentUser': getCurrentUser,
		'getActiveContentPage': getActiveContentPage,
		'getDbpDependency': getDbpDependency,
		'handleDashboardMenuClick': handleDashboardMenuClick,
		'dbpIsBusy': dbpIsBusy,
		'logout': logout,
		'resetDbpState': resetDbpState,
		'resetDashboardState': resetDashboardState,
		'setDbpBusyState': setDbpBusyState,
		'submitPostComment': submitPostComment,
		'transitionDashboardPage': transitionDashboardPage
	};
}(momentumHelperModule);
/**
 * Module containing the dashboard pages templates to be rendered.
 * @param {Object} helper - Helper functions module.
 * @param {Object} app - App related functions.
 * @return {Object} publicApi - Api containing references to the module functions.
 */
var momentumTemplatesModule = function (helper, app) {

	var commentsForm; // Form to add new comments to a post
	var elems; // Object containing references to static, reused DOM elements
	var requests; // Different requests info, used to render pages
	var pageTitleBase; // The starting document title base

	commentsForm = setNewCommentForm();
	elems = helper.getAppElems();
	requests = helper.getRequests();
	pageTitleBase = document.title;

	/**
  * Render a dashboard page with some passed-in content.
  * @param {Array} content - Content to render in the page.
  * @param {Object} request - Info on the request, including the type, used to select the correct render.
  * @param {Object} parent - The dashboard page in which the content should be rendered.
  * @param {Function} callback - Function to call once page is finished rendering.
 */
	function render(content, request, parent, callback) {
		var renderTemplates; // The different templates that can be rendered

		renderTemplates = {
			'posts': renderPosts,
			'userAlbums': renderUserAlbums,
			'album': renderAlbum,
			'photo': renderPhoto,
			'post': renderPost,
			'user': renderUser
		};

		callback = callback || function () {};

		// Empty the parent
		helper.emptyElem(parent);

		helper.setData(elems.dashboardContentPage, 'processing', false);

		// Use the correct rendering template function
		renderTemplates[request.type](content, request, parent, callback);

		/**
   * Render a list of multiple posts.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
   * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderPosts(content, request, parent, callback) {
			var entry; // The current content entry being looped through
			var href; // The href attribute on the post element
			var post; // Every post element being created
			var postContent; // Every post content element
			var postTitle; // Every post title element

			// Set the page title
			if ('titleQuery' in request) {
				helper.getApiData(request.titleQuery, function (user) {
					setTitle("Posts by: " + user.username);
				});
			} else if ('title' in request) {
				setTitle(request.title);
			} else {
				setTitle('Page');
			}

			// Create all new elements and append to page
			for (var i = 0; i < content.length; i++) {

				entry = content[i];

				// Post
				post = helper.createAnchor();
				post.classList.add('list-group-item', 'list-group-item-action');
				helper.setData(post, 'id', entry.id);
				helper.setData(post, 'req', 'post');

				// Title
				postTitle = document.createElement('h5');
				postTitle.classList.add('list-group-item-heading');
				postTitle.appendChild(document.createTextNode(entry.title));
				post.appendChild(postTitle);

				// Content
				postContent = document.createElement('p');
				postContent.classList.add('list-group-item-text');
				postContent.appendChild(document.createTextNode(entry.body));
				post.appendChild(postContent);

				// Handle click on post event
				helper.addEvent(post, 'click', renderNewPage);

				// Append the final post
				parent.appendChild(post);
			}

			afterRender(content, request, parent, callback);
		}

		/**
   * Render a page containing all the albums belonging to a user.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
  	 * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderUserAlbums(content, request, parent, callback) {
			var album; // Element containing an album. Element is clonable
			var albumContentBlock; // An album overlay, containing the title text
			var albumLink; // Link leading to the album page
			var albums; // All of the album thumbnails
			var albumThumb; // An album's thumbnail
			var albumTitle; // An album's title
			var entry; // The current content entry being looped through
			var newAlbum; // Album element. Created from cloning the base one, 'album'

			// Set page title
			helper.getApiData("users/" + request.userId, function (result) {
				setTitle("Albums by: " + result.username);
			});

			// Albums
			albums = document.createElement('div');
			albums.classList.add('albums');

			// Add albums element to parent, keep reference to it
			parent.appendChild(albums);
			albums = parent.lastChild;

			// Album
			album = helper.createAnchor();
			album.classList.add('card', 'list-group-item-action');

			// Title
			albumTitle = document.createElement('h3');
			albumTitle.classList.add('card-title');

			// Overlay
			albumContentBlock = document.createElement('div');
			albumContentBlock.classList.add('card-block');
			albumContentBlock.appendChild(albumTitle);

			// Make up clonable album element
			album.appendChild(albumContentBlock);

			// Loop through every album and append
			for (var i = 0; i < content.length; i++) {

				entry = content[i];

				(function processEntry() {
					var currentEntry = entry; // Keep reference to the currently looped entry

					helper.getApiData("albums/" + currentEntry.id + "/photos", function (result) {
						albums.appendChild(getAlbumElem(currentEntry.id, result[0].thumbnailUrl, currentEntry.title, album));
					});
				})();
			}

			afterRender(content, request, parent, callback);

			/**
    * Clone album element, place content inside and return it.
    * @param {String} albumId - The album's ID.
    * @param {String} src - The album's first image's source.
    * @param {String} title - The album's title.
    * @param {Object} base - The base dom element object to clone.
    * @return {Object} elem - The album element.
    */
			function getAlbumElem(albumId, src, title, base) {
				var album; // The album element
				var image; // The album image

				// Add the image
				image = new Image();

				image.onload = function () {
					album.appendChild(image);
				};

				image.classList.add('card', 'album-thumbnail');

				album = base.cloneNode(true);
				helper.setData(album, 'id', albumId);
				helper.setData(album, 'req', 'album');

				// Handle click on album event
				helper.addEvent(album, 'click', renderNewPage);

				// Set title to heading
				album.firstChild.firstChild.appendChild(document.createTextNode(title));

				// Set src to thumbnail
				image.src = src;

				return album;
			}
		}

		/**
   * Render an album page.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
  	 * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderAlbum(content, request, parent, callback) {
			var albumText; // Element containing all text pertaining to the album
			var albumTitle; // The album's title
			var entry; // The current content entry being looped through
			var photo; // Photo element (anchor)
			var photos; // Element containing all photos

			// Set the title
			setTitle(content.title);

			// Photos
			photos = document.createElement('div');
			photos.classList.add('photos', 'card', 'card-block', 'post');

			// Append photos to parent, but keep reference to it
			parent.appendChild(photos);
			photos = parent.lastChild;

			// Photo
			photo = helper.createAnchor();
			photo.classList.add('photo');

			// Text elem
			albumText = document.createElement('div');
			albumText.classList.add('album-text');

			// Title elem
			albumTitle = document.createElement('h3');
			albumTitle.classList.add('card-title', 'title');
			albumTitle.appendChild(document.createTextNode(content.title));
			albumText.appendChild(albumTitle);

			// Add the user element
			addUser(function () {
				photos.appendChild(albumText);

				// Loop through album photos
				helper.getApiData("albums/" + content.id + "/photos", function (result) {

					for (var i = 0; i < result.length; i++) {
						entry = result[i];
						photos.appendChild(getPhotoElem(entry.id, entry.thumbnailUrl, photo));
					}
					afterRender(content, request, parent, callback);
				});
			});

			/**
    * Clone photo element, place content inside and return it.
    * @param {String} photoId - The photo's ID.
    * @param {String} src - The photo's image's source.
    * @param {Object} base - The base dom element object to clone.
    * @return {Object} elem - The album element.
    */
			function getPhotoElem(photoId, src, base) {
				var img; // Image element
				var photo; // Photo element

				img = new Image();

				img.onload = function () {
					photo.appendChild(img);
				};

				photo = base.cloneNode(true);

				helper.setData(photo, 'id', photoId);
				helper.setData(photo, 'req', 'photo');

				// Handle click on photo
				helper.addEvent(photo, 'click', renderNewPage);

				// Set src to thumbnail
				img.src = src;

				return photo;
			}

			/**
    * Add the user to the album element.
    * @param {Function} callback - Function to call after user is added.
    */
			function addUser(callback) {
				var userElem; // The user's element
				var userAround; // Element wrapping around user element

				helper.getApiData("users/" + content.userId, function (result) {

					// User
					userElem = helper.createAnchor(result.username);
					userElem.classList.add('post-user');

					helper.setData(userElem, 'id', content.userId);
					helper.setData(userElem, 'req', 'user');

					// User click event handler
					helper.addEvent(userElem, 'click', renderNewPage);

					// User wrapper
					userAround = document.createElement('div');
					userAround.classList.add('user-around');
					userAround.appendChild(document.createTextNode('Posted by: '));
					userAround.appendChild(userElem);

					albumText.appendChild(userAround);

					callback();
				});
			}
		}

		/**
   * Render a single photo page.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
  	 * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderPhoto(content, request, parent, callback) {
			var img; // The photo page image
			var photo; // Element containing the whole photo page
			var title; // The photo page title

			setTitle(content.title);

			// Photo page container
			photo = document.createElement('div');
			photo.classList.add('card', 'card-block', 'post', 'single-photo');

			// Title
			title = document.createElement('h3');
			title.classList.add('card-title', 'title');
			title.appendChild(document.createTextNode(content.title));

			// Image
			img = new Image();

			img.onload = function () {
				photo.appendChild(img);
			};

			img.src = content.url;

			photo.appendChild(title);

			// Append
			parent.appendChild(photo);
			afterRender(content, request, parent, callback);
		}

		/**
   * Render a single post.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
   * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderPost(content, request, parent, callback) {
			var postElem; // The post's main element
			var postContentElem; // The post's content element
			var postTitleElem; // The post's title element

			setTitle(content.title);

			// Post
			postElem = document.createElement('div');
			postElem.classList.add('card', 'card-block', 'post');

			// Title
			postTitleElem = document.createElement('h3');
			postTitleElem.innerHTML = content.title;
			postTitleElem.classList.add('card-title', 'title');

			// Content
			postContentElem = document.createElement('p');
			postContentElem.innerHTML = content.body;
			postContentElem.classList.add('card-text', 'content');

			// Add all the elements
			postElem.appendChild(postTitleElem);

			addUser(function () {
				parent.appendChild(postElem);

				addComments(function () {
					afterRender(content, request, parent, callback);
				});
			});

			/**
    * Add the user to the post element.
    * @param {Function} callback - Function to call after user is added.
    */
			function addUser(callback) {
				var userElem; // The user's element
				var userAround; // Element wrapping around user element

				helper.getApiData("users/" + content.userId, function (result) {

					// User
					userElem = helper.createAnchor(result.username);
					userElem.classList.add('post-user');

					helper.setData(userElem, 'id', content.userId);
					helper.setData(userElem, 'req', 'user');

					// User click event handler
					helper.addEvent(userElem, 'click', renderNewPage);

					// User wrapper
					userAround = document.createElement('div');
					userAround.classList.add('user-around');
					userAround.appendChild(document.createTextNode('Posted by: '));
					userAround.appendChild(userElem);

					postElem.appendChild(userAround);
					postElem.appendChild(postContentElem);

					callback();
				});
			}

			/**
    * Get and add comments to the post element.
    * @param {Function} callback - Function to call after comments are added.
    */
			function addComments(callback) {
				helper.getApiData("posts/" + content.id + "/comments", function (result) {
					var addCommentForm; // Section including the "Add a comment" form
					var comment; // Element to contain a comment. Cloned to create new comment elements.
					var commentBody; // Main body element inside of a comment
					var comments; // Contains all comments
					var commentTitle; // Title element inside of a comment
					var commentUser; // User element inside of a comment
					var commentEmail; // The user's email
					var commentsElemTitle; // Title before comments
					var commentsElemTitleAround; // Section before comments, contains title
					var entry; // The current content entry being looped through
					var newComment; // Every new comment element

					// "Add a comment" form
					addCommentForm = getNewCommentForm(content.id);

					// Comments title section
					commentsElemTitleAround = document.createElement('div');
					commentsElemTitleAround.classList.add('card', 'card-block', 'before-comments-title');

					commentsElemTitle = document.createElement('h3');
					commentsElemTitle.classList.add('card-title');
					commentsElemTitle.appendChild(document.createTextNode(getCommentsTitleText(result.length)));

					helper.setData(commentsElemTitle, 'comments', result.length);

					commentsElemTitleAround.appendChild(commentsElemTitle);

					parent.appendChild(addCommentForm);
					parent.appendChild(commentsElemTitleAround);

					// Comments
					comments = document.createElement('div');
					comments.classList.add('comments', 'list-group');

					// Comment
					comment = document.createElement('div');
					comment.classList.add('list-group-item');

					commentTitle = document.createElement('h4');
					commentTitle.classList.add('list-group-item-heading');

					commentEmail = helper.createAnchor('Email this user');
					commentEmail.classList.add('user-email');

					commentUser = document.createElement('div');
					commentUser.classList.add('user');
					commentUser.appendChild(commentEmail);

					commentBody = document.createElement('p');
					commentBody.classList.add('list-group-item-text');

					comment.appendChild(commentTitle);
					comment.appendChild(commentUser);
					comment.appendChild(commentBody);

					// Output all comments
					for (var i = 0; i < result.length; i++) {

						entry = result[i];
						newComment = getNewComment(entry.name, entry.email, entry.body, comment);

						if (comments.firstChild) {
							comments.insertBefore(newComment, comments.firstChild);
						} else {
							comments.appendChild(newComment);
						}
					}

					parent.appendChild(comments);
					callback();
				});

				/**
     * Get the appropriate title for the comments amount title.
     * @param {Integer} commentsAmount - The amount of comments.
     * @return {Object} title - The title text.
     */
				function getCommentsTitleText(commentsAmount) {
					if (commentsAmount === 1) {
						return '1 comment';
					} else if (commentsAmount > 1) {
						return commentsAmount + " comments";
					} else {
						return 'No comments';
					}
				}

				/**
     * Get a new comment.
     * @param {String} title - The title of the comment.
     * @param {String} email - The user email.
     * @param {String} body - The body text.
     * @param {String} base - The base to use as a starting element.
     * @return {Object} comment - The new comment element.
     */
				function getNewComment(title, email, body, base) {
					var newComment; // New comment to return.

					newComment = base.cloneNode(true);

					newComment.childNodes[0].appendChild(document.createTextNode(title));
					newComment.childNodes[1].firstChild.setAttribute('href', "mailto:" + email);
					newComment.childNodes[2].appendChild(document.createTextNode(body));

					return newComment;
				}

				/**
     * Get the new comment form.
     * @return {Object} form - The form to enter a new comment.
     */
				function getCommentForm() {

					var button; // The form's button
					var form; // The form
					var input; // The form's title input
					var textArea; // The form's body input

					// Form
					form = document.createElement('form');
					form.setAttribute('method', 'post');
					form.setAttribute('action', '');
					form.classList.add('comment-form');

					helper.setData(form, 'postid', content.id);

					// Add submit event handler on the form
					helper.addEvent(form, 'submit', app.submitPostComment);

					// Input
					var input = document.createElement('input');
					input.setAttribute('placeholder', 'Enter a title...');
					input.setAttribute('type', 'text');
					input.classList.add('field', 'title-field');
					input.setAttribute('name', 'name');

					// Textarea
					var textArea = document.createElement('textarea');
					textArea.setAttribute('placeholder', 'Enter a comment...');
					textArea.classList.add('field', 'comment-field');
					textArea.setAttribute('name', 'body');

					// Button
					var button = document.createElement('input');
					button.setAttribute('type', 'submit');
					button.setAttribute('value', 'Send');
					button.classList.add('btn', 'btn-primary', 'btn-block');

					form.appendChild(input);
					form.appendChild(textArea);
					form.appendChild(button);

					return form;
				}
			}
		}

		/**
   * Render a user profile page.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
   * @param {Function} callback - Function to call once page is finished rendering.
   */
		function renderUser(content, request, parent, callback) {
			var userEmailElem; // Anchor containing the user's email
			var userElem; // The main element wrapping around the user info
			var userInfo; // Element containing all the user info
			var userTitle; // The user profile page title
			var userWebsiteElem; // Anchor containing the user's website

			setTitle("User: " + content.username);

			// User
			userElem = document.createElement('div');
			userElem.classList.add('card', 'card-block', 'user');

			// Title
			userTitle = document.createElement('h3');
			userTitle.classList.add('card-title', 'title');
			userTitle.appendChild(document.createTextNode(content.username));

			// Email
			userEmailElem = helper.createAnchor(content.email, "mailto:" + content.email);

			// Website
			userWebsiteElem = helper.createAnchor(content.website, "http://" + content.website);
			userWebsiteElem.setAttribute('target', '_blank');

			// Info
			userInfo = document.createElement('ul');
			userInfo.classList.add('user-info');

			userInfo.appendChild(createUserInfoPair('Name', content.name));
			userInfo.appendChild(createUserInfoPair('Email', userEmailElem));
			userInfo.appendChild(createUserInfoPair('Phone', content.phone));
			userInfo.appendChild(createUserInfoPair('Website', userWebsiteElem));
			userInfo.appendChild(createUserInfoPair('City', content.address.city));
			userInfo.appendChild(createUserInfoPair('Company', content.company.name));

			// Append everything
			userElem.appendChild(userTitle);
			userElem.appendChild(userInfo);
			parent.appendChild(userElem);

			afterRender(content, request, parent, callback);

			/**
    * Create an element containing a name/info pair of the user info.
    * @param {String} name - The name of the info.
    * @param {String|Object} value - The value of the info. Can be a string or a DOM element object.
    * @return {Object} infoElem - Element containing the infos.
    */
			function createUserInfoPair(name, value) {
				var infoElem; // Element containing the info
				var infoName; // Element containing info name
				var infoValue; // Element containing info value

				infoElem = document.createElement('li');

				infoName = document.createElement('span');
				infoName.classList.add('name');
				infoName.appendChild(document.createTextNode(name));

				infoValue = document.createElement('span');
				infoValue.classList.add('value');

				if (typeof value === 'string') {
					infoValue.appendChild(document.createTextNode(value));
				} else {
					infoValue.appendChild(value);
				}

				infoElem.appendChild(infoName);
				infoElem.appendChild(infoValue);

				return infoElem;
			}
		}

		/**
   * Function executed at the end of the main render function.
   * @param {Array} content - Content to render in the page.
   * @param {Object} request - Info on the request, including the type, used to select the correct render.
   * @param {Object} parent - The dashboard page in which the content should be rendered.
   * @param {Function} callback - Function to call once page is finished rendering.
   */
		function afterRender(content, request, parent, callback) {
			parent.classList.add('active');

			// Set the dashboard page to non-busy state
			app.setDbpBusyState(false);

			// Remove any dbp that come after the new, current dashboard page. To avoid having the 'next' option available to irrelevent pages.
			while (helper.getElemAfter(parent) != null) {
				var nextElem = helper.getElemAfter(parent);
				nextElem.parentElement.removeChild(nextElem);
			}

			callback();
		}

		/**
   * Set the title, both in the data-attribute of the page and the title element.
   * @param {String} title - The title.
   */
		function setTitle(title) {
			helper.setData(parent, 'title', title);

			elems.dashboardContentTitle.innerHTML = title;
			document.title = pageTitleBase + " - " + title;
		}
	}

	/**
  * Render a new page. Attached to every clickable dynamically created elements in content pages.
  * @param {Event} event - The event.
  */
	function renderNewPage(event) {
		var currentContentPage; // The currently active content page
		var lastVisited; // The last element previously clicked on before this one
		var nextContentPage; // The content page after the current one
		var request; // The request object to use to render the page

		event.preventDefault ? event.preventDefault() : event.returnValue = false;

		// Set this element to the "last-visited" one
		lastVisited = document.querySelectorAll('.last-visited')[0];

		if (lastVisited) {
			lastVisited.classList.remove('last-visited');
		}

		this.classList.add('last-visited');

		currentContentPage = app.getActiveContentPage();
		nextContentPage = helper.getElemAfter(currentContentPage);
		request = requests[helper.getData(this, 'req')](helper.getData(this, 'id'));

		// If next page doesn't exist, create it
		if (typeof nextContentPage === 'undefined' || nextContentPage === null) {
			var next = void 0; // The next content page

			// Create the next content page
			next = document.createElement('div');

			helper.setData(next, 'currentcontent', 'true');
			helper.setData(next, 'pagenum', parseInt(helper.getData(currentContentPage, 'pagenum')) + 1);

			next.classList.add('inner-content', 'list-group-active');

			// Append it
			elems.dbpContentContainer.appendChild(next);
			nextContentPage = helper.getElemAfter(currentContentPage);
		}

		// Set the content page state to "processing"
		app.setDbpBusyState(true);

		// Request the content and render page with it
		helper.getApiData(request.query, function (result) {
			render(result, request, nextContentPage, function () {
				app.dbpChangePage('next');
			});
		});
	}

	/**
  * Create the form to add new elements and set inside this module. To be cloned inside of the renderPosts function.
  */
	function setNewCommentForm() {
		var button; // The form's button
		var form; // The form
		var heading; // The heading above the form
		var input; // The form's title input
		var outerDiv; // Div wrapping around the entire form
		var textArea; // The form's body input

		// Form outer div
		outerDiv = document.createElement('div');
		outerDiv.classList.add('before-comments', 'card', 'card-block');

		// Form heading
		heading = document.createElement('h3');
		heading.classList.add('title', 'card-title');
		heading.appendChild(document.createTextNode('Add a comment'));

		// Form
		form = document.createElement('form');
		form.setAttribute('method', 'post');
		form.setAttribute('action', '');
		form.classList.add('comment-form');

		// Input
		var input = document.createElement('input');
		input.setAttribute('placeholder', 'Enter a title...');
		input.setAttribute('type', 'text');
		input.classList.add('field', 'title-field');
		input.setAttribute('name', 'name');

		// Textarea
		var textArea = document.createElement('textarea');
		textArea.setAttribute('placeholder', 'Enter a comment...');
		textArea.classList.add('field', 'comment-field');
		textArea.setAttribute('name', 'body');

		// Button
		var button = document.createElement('input');
		button.setAttribute('type', 'submit');
		button.setAttribute('value', 'Send');
		button.classList.add('btn', 'btn-primary', 'btn-block');

		form.appendChild(input);
		form.appendChild(textArea);
		form.appendChild(button);

		outerDiv.appendChild(heading);
		outerDiv.appendChild(form);

		return outerDiv;
	}

	/**
  * Fetch a copy of the module commentsForm, used to post new comments.
  * @param {String} dataPostId - The value of the form's data-postid attribute.
  * @return {Object} form - The form wrapper element containing the form and heading.
  */
	function getNewCommentForm(dataPostId) {
		var formWrapper; // The element wrapped around the form
		var form; // The form element itself

		formWrapper = commentsForm.cloneNode(true);
		form = formWrapper.lastChild;

		helper.addEvent(form, 'submit', app.submitPostComment);
		helper.setData(form, 'postid', dataPostId);

		return formWrapper;
	}

	return {
		'render': render,
		'renderNewPage': renderNewPage,
		'requests': requests
	};
}(momentumHelperModule, momentumFunctionsModule);
/**
 * Main module containing the code for the Momentum Front End app.
 * @param {Object} helper - Helper functions module.
 * @param {Object} app - App related functions.
 * @param {Object} dbp - Module to render dashboard pages.
 * @return {Object} publicApi - Api containing references to the module functions.
 */
var momentumModule = function momentumModule(helper, app, dbp) {

	var elems = helper.getAppElems(); // Static, reused DOM elements

	/**
  * Initialize all the things!
  * @param {String} url - Base URL from which the API data is fetched.
  */
	function init(url) {

		// Set the api url
		helper.setApiUrl(url);

		// Give 'momentum-templates' module reference to 'momentum-functions'
		app.getDbpDependency(dbp);

		// Add events to each dashboard menu items which request appropriate content and renders a page with it
		for (var i = 0; i < elems.dashboardMenuItems.length; i++) {
			helper.addEvent(elems.dashboardMenuItems[i], 'click', app.handleDashboardMenuClick);
		}

		// Add login/out events
		helper.addEvent(document.getElementById('login'), 'submit', app.authenticate);
		helper.addEvent(document.getElementById('logout'), 'click', app.logout);

		// Secondary dbp previous/next buttons
		helper.addEvent(elems.contentBack, 'click', app.dbpPreviousClick);
		helper.addEvent(elems.contentNext, 'click', app.dbpNextClick);
	}

	return {
		'init': init
	};
}(momentumHelperModule, momentumFunctionsModule, momentumTemplatesModule);
'use strict';
momentumModule.init('http://jsonplaceholder.typicode.com');